<!doctype html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>可交互 3D 方块 + 物理引擎（Three.js + cannon-es）</title>
  <style>
    html,body{height:100%;margin:0;font-family:system-ui,Segoe UI,Roboto,"Noto Sans",sans-serif}
    #container{width:100%;height:100vh;display:block;overflow:hidden;position:relative;background:#111}
    .ui{
      position: absolute;right: 12px;top: 12px;width:260px;padding:10px;background:rgba(255,255,255,0.06);backdrop-filter: blur(6px);border-radius:8px;color:#eee;font-size:14px
    }
    .ui button, .ui input, .ui label, .ui select{display:block;width:100%;margin:6px 0}
    .hint{position:absolute;left:12px;bottom:12px;color:#ddd;background:rgba(0,0,0,0.25);padding:8px;border-radius:6px}
  </style>
</head>
<body>
  <div id="container"></div>
  <div class="ui">
    <strong>场景控制</strong>
    <label>方块大小（单边 px）<input id="size" type="range" min="0.2" max="3" step="0.1" value="1"></label>
    <label>质量（kg）<input id="mass" type="range" min="0.1" max="10" step="0.1" value="1"></label>
    <label>颜色<select id="color"><option value="#ff6b6b">红</option><option value="#4d96ff">蓝</option><option value="#ffd93d">黄</option><option value="#8af27a">绿</option></select></label>
    <button id="add">添加方块</button>
    <button id="spawn-random">随机批量生成</button>
    <button id="spawn-grid">生成方阵</button>
    <hr>
    <label>重力：<input id="gravity" type="range" min="-30" max="0" step="0.5" value="-9.82"></label>
    <button id="reset">重置场景</button>
    <hr>
    <strong>交互</strong>
    <p style="margin:6px 0">左键拖动旋转视角；鼠标滚轮缩放；右键平移。<br>点击方块并拖动（按住 Shift 可施加更大力）</p>
  </div>
  <div class="hint">点击方块：施加冲量；拖动（按住鼠标）可将抓取点拖动。</div>

  <script type="importmap">{
  "imports": {
    "three": "https://cdn.jsdelivr.net/npm/three@0.150.1/build/three.module.js",
    "three/examples/jsm/controls/OrbitControls.js": "https://cdn.jsdelivr.net/npm/three@0.150.1/examples/jsm/controls/OrbitControls.js",
    "cannon-es": "https://cdn.jsdelivr.net/npm/cannon-es@0.20.0/dist/cannon-es.js"
  }
}</script>

<script type="module">
    // 使用 CDN 模块（需要网络）
    import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.150.1/build/three.module.js';
    import { OrbitControls } from 'https://cdn.jsdelivr.net/npm/three@0.150.1/examples/jsm/controls/OrbitControls.js';
    import * as CANNON from 'https://cdn.jsdelivr.net/npm/cannon-es@0.20.0/dist/cannon-es.js';

    // 基本 Three.js 场景
    const container = document.getElementById('container');
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x111111);

    const camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 2000);
    camera.position.set(6,4,8);

    const renderer = new THREE.WebGLRenderer({antialias:true});
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.shadowMap.enabled = true;
    container.appendChild(renderer.domElement);

    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;

    // 环境光与方向光
    scene.add(new THREE.AmbientLight(0xffffff, 0.45));
    const dir = new THREE.DirectionalLight(0xffffff, 0.9);
    dir.position.set(5,10,2);
    dir.castShadow = true;
    dir.shadow.mapSize.set(2048,2048);
    dir.shadow.camera.left = -10;dir.shadow.camera.right = 10;dir.shadow.camera.top = 10;dir.shadow.camera.bottom = -10;
    scene.add(dir);

    // 地面网格
    const groundGeo = new THREE.PlaneGeometry(200,200);
    const groundMat = new THREE.MeshStandardMaterial({color:0x222222,metalness:0.2,roughness:0.8});
    const ground = new THREE.Mesh(groundGeo, groundMat);
    ground.rotation.x = -Math.PI/2;
    ground.receiveShadow = true;
    scene.add(ground);

    // 物理世界（Cannon-es）
    const world = new CANNON.World({gravity: new CANNON.Vec3(0,-9.82,0)});
    world.broadphase = new CANNON.SAPBroadphase(world);
    // 提高迭代次数以获得更稳定的碰撞求解（代价是性能）
    world.solver.iterations = 20;
    // 物理材质：调节摩擦和弹性，避免物体过滑或过弹
    const defaultMaterial = new CANNON.Material('default');
    const groundMaterial = new CANNON.Material('ground');
    const boxMaterial = new CANNON.Material('box');
    const defaultContact = new CANNON.ContactMaterial(defaultMaterial, defaultMaterial, { friction: 0.35, restitution: 0.05 });
    const groundBoxContact = new CANNON.ContactMaterial(groundMaterial, boxMaterial, { friction: 0.6, restitution: 0.02 });
    world.defaultContactMaterial = defaultContact;

    // 地面物理体
    const groundBody = new CANNON.Body({mass:0,shape: new CANNON.Plane(), material: groundMaterial});
    groundBody.quaternion.setFromEuler(-Math.PI/2,0,0);
    world.addBody(groundBody);

    // 同步数组
    const objects = [];

    function addCube({size=1, mass=1, position=new THREE.Vector3(0,4,0), color='#ff6b6b'}){
      // THREE 物体
      const geo = new THREE.BoxGeometry(size, size, size);
      const mat = new THREE.MeshStandardMaterial({color: color});
      const mesh = new THREE.Mesh(geo, mat);
      mesh.castShadow = true;
      mesh.receiveShadow = true;
      mesh.scale.set(1,1,1);
      mesh.position.copy(position);
      scene.add(mesh);

      // CANNON 物体
      const halfExtents = new CANNON.Vec3(size/2, size/2, size/2);
      const boxShape = new CANNON.Box(halfExtents);
      const body = new CANNON.Body({mass: mass, shape: boxShape});
      body.position.set(position.x, position.y, position.z);
      // 给一点初始小旋转速度，方便看到物理效果
      body.angularVelocity.set(Math.random()*1-0.5, Math.random()*1-0.5, Math.random()*1-0.5);
      body.angularDamping = 0.3;
      // 轻微线性阻尼让物体运动更稳定，减少抖动
      body.linearDamping = 0.05;
      body.material = boxMaterial;
      world.addBody(body);

      objects.push({mesh, body, size});
      return {mesh, body};
    }

    // UI 相关
    const sizeInput = document.getElementById('size');
    const massInput = document.getElementById('mass');
    const colorSelect = document.getElementById('color');
    document.getElementById('add').addEventListener('click', ()=>{
      const size = parseFloat(sizeInput.value);
      const mass = parseFloat(massInput.value);
      const color = colorSelect.value;
      addCube({size, mass, position: new THREE.Vector3((Math.random()-0.5)*2, 4 + Math.random()*2, (Math.random()-0.5)*2), color});
    });

    document.getElementById('spawn-random').addEventListener('click', ()=>{
      for(let i=0;i<12;i++){
        addCube({size: 0.3+Math.random()*2, mass: 0.2+Math.random()*8, position: new THREE.Vector3((Math.random()-0.5)*6, 2+i*0.6, (Math.random()-0.5)*6), color: ['#ff6b6b','#4d96ff','#ffd93d','#8af27a'][Math.floor(Math.random()*4)]});
      }
    });

    document.getElementById('spawn-grid').addEventListener('click', ()=>{
      const n = 5; const spacing = 1.2;
      for(let x=0;x<n;x++) for(let y=0;y<n;y++) for(let z=0;z<2;z++){
        addCube({size:0.9, mass:1, position:new THREE.Vector3((x-n/2)*spacing, 1 + y*spacing + z*1.5, (z-n/2)*spacing), color:'#ffd93d'});
      }
    });

    document.getElementById('gravity').addEventListener('input', (e)=>{
      const g = parseFloat(e.target.value);
      world.gravity.set(0, g, 0);
    });

    document.getElementById('reset').addEventListener('click', ()=>{
      // 移除物体
      for(const o of objects){
        scene.remove(o.mesh);
        world.removeBody(o.body);
      }
      objects.length = 0;
      // 回到默认相机
      camera.position.set(6,4,8);
      controls.target.set(0,0.5,0);
    });

    // 物理与渲染同步
    const timeStep = 1/60;
let lastTime;

function animate(time){
  requestAnimationFrame(animate);
  if(!lastTime) lastTime = time;
  const dt = Math.min((time - lastTime)/1000, 0.05);

  // 在物理步前应用弹簧力与阻尼（如果正在拖拽）
  if(dragged){
    try{
      const worldPoint = dragged.body.pointToWorldFrame(dragged.localPoint);
      const targetC = new CANNON.Vec3(dragged.target.x, dragged.target.y, dragged.target.z);
      const posDiff = targetC.vsub(worldPoint);
      // 弹簧刚度（可调），设得太大容易导致震荡或释放时飞出去
      const k = 100; // 推荐范围 50 - 300
      posDiff.scale(k, posDiff);
      // 粗糙阻尼：估计线速度并产生阻力
      const v = new CANNON.Vec3(dragged.body.velocity.x, dragged.body.velocity.y, dragged.body.velocity.z);
      const damping = 20; // 可调
      const dampForce = new CANNON.Vec3(v.x * damping, v.y * damping, v.z * damping);
      posDiff.vsub(dampForce, posDiff);
      // 限制最大力
      const maxForce = 2000;
      const mag = Math.sqrt(posDiff.x*posDiff.x + posDiff.y*posDiff.y + posDiff.z*posDiff.z) || 0.0001;
      if(mag > maxForce){ posDiff.scale(maxForce / mag, posDiff); }
      dragged.body.applyForce(posDiff, worldPoint);
      // 提高角阻尼，避免抓取时不停旋转
      dragged.body.angularDamping = 0.9;
    }catch(e){ /* ignore */ }
  }

  world.step(timeStep, dt);
  // 同步位置
  for(const o of objects){
    o.mesh.position.copy(o.body.position);
    o.mesh.quaternion.copy(o.body.quaternion);
  }
  controls.update();
  renderer.render(scene, camera);
  lastTime = time;
}
// requestAnimationFrame(animate);
//   if(!lastTime) lastTime = time;
//   const dt = Math.min((time - lastTime)/1000, 0.05);

//   // 如果正在拖拽，使用弹簧力把物体拉向目标点（在 step 之前施加力）
//   if(typeof dragged !== 'undefined' && dragged){
//     try{
//       const worldPoint = dragged.body.pointToWorldFrame(dragged.localPoint);
//       const targetC = new CANNON.Vec3(dragged.target.x, dragged.target.y, dragged.target.z);
//       const force = targetC.vsub(worldPoint);
//       // 阻尼系数（与物体质量有关），过大会导致拉扯生硬，过小则感觉软
//       const k = 1200; // 可根据需要调节
//       force.scale(k, force);
//       dragged.body.applyForce(force, worldPoint);
//     }catch(e){ /* ignore */ }
//   }

//   world.step(timeStep, dt);
//   // 同步位置
//   for(const o of objects){
//     o.mesh.position.copy(o.body.position);
//     o.mesh.quaternion.copy(o.body.quaternion);
//   }
//   controls.update();
//   renderer.render(scene, camera);
//   lastTime = time;
// }
// requestAnimationFrame(animate);
//       if(!lastTime) lastTime = time;
//       const dt = Math.min((time - lastTime)/1000, 0.05);
//       world.step(timeStep, dt);
//       // 同步位置
//       for(const o of objects){
//         o.mesh.position.copy(o.body.position);
//         o.mesh.quaternion.copy(o.body.quaternion);
//       }
//       controls.update();
//       renderer.render(scene, camera);
//       lastTime = time;
//     }
    requestAnimationFrame(animate);

    // 尺寸调整
    window.addEventListener('resize', ()=>{
      camera.aspect = window.innerWidth/window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });

    // 鼠标交互：点选 + 拖拽（使用弹簧力）
    const raycaster = new THREE.Raycaster();
    const mouse = new THREE.Vector2();

    let dragged = null; // {mesh, body, localPoint: CANNON.Vec3, target: THREE.Vector3}

    function getMouseWorldPointAtDistance(clientX, clientY, distance){
      const rect = renderer.domElement.getBoundingClientRect();
      mouse.x = ((clientX - rect.left) / rect.width) * 2 - 1;
      mouse.y = -((clientY - rect.top) / rect.height) * 2 + 1;
      raycaster.setFromCamera(mouse, camera);
      const ray = raycaster.ray;
      if(distance === undefined || distance === null){
        // fallback: 使用 y=0 平面的交点
        const t = (0 - ray.origin.y) / ray.direction.y;
        return ray.origin.clone().add(ray.direction.clone().multiplyScalar(t));
      } else {
        return ray.origin.clone().add(ray.direction.clone().multiplyScalar(distance));
      }
    }

    // 控制：只有按住 Shift 时允许改变视角（旋转/平移），缩放保持可用
    controls.enableRotate = false;
    controls.enablePan = false;
    controls.enableZoom = true;

    renderer.domElement.addEventListener('pointerdown', (ev)=>{
  // 如果按住 Shift，就只操作视角（旋转/平移），不进行物体选中
  if(ev.shiftKey){
    controls.enableRotate = true;
    controls.enablePan = true;
    return; // 让 OrbitControls 处理后续拖动
  }
  // 否则禁用 OrbitControls 的旋转/平移（缩放仍可用）
  controls.enableRotate = false;
  controls.enablePan = false;

  // 只有左键用于选择和拖拽物体
  if(ev.button !== 0) return;
  const rect = renderer.domElement.getBoundingClientRect();
  mouse.x = ((ev.clientX - rect.left) / rect.width) * 2 - 1;
  mouse.y = -((ev.clientY - rect.top) / rect.height) * 2 + 1;
  raycaster.setFromCamera(mouse, camera);
  const intersects = raycaster.intersectObjects(objects.map(o=>o.mesh));
  if(intersects.length>0){
    const it = intersects[0];
    const sel = objects.find(o=>o.mesh===it.object);
    if(!sel) return;
    // 记录抓取点在物体局部坐标（更精确）并保存与摄像机的距离
    const hitPoint = it.point;
    const worldHit = new CANNON.Vec3(hitPoint.x, hitPoint.y, hitPoint.z);
    const localPoint = sel.body.pointToLocalFrame(worldHit);
    const distance = camera.position.distanceTo(hitPoint);
    dragged = {mesh: sel.mesh, body: sel.body, localPoint, target: hitPoint.clone(), distance, _prevLinearDamping: sel.body.linearDamping, _prevAngularDamping: sel.body.angularDamping};
    // 增强阻尼，避免被抓取时抖动过大
    sel.body.linearDamping = 0.7;
  } else {
    // 没点中：对方向发射一个小冲量（推动物体）
    const all = objects.map(o=>o.mesh);
    const ints = raycaster.intersectObjects(all);
    if(ints.length>0){
      const it = ints[0];
      const sel = objects.find(o=>o.mesh===it.object);
      if(sel){
        const impulse = new CANNON.Vec3().copy(raycaster.ray.direction).scale(ev.shiftKey? -30 : -10);
        sel.body.applyImpulse(impulse, sel.body.pointToLocalFrame(new CANNON.Vec3(it.point.x, it.point.y, it.point.z)));
      }
    }
  }
});

    renderer.domElement.addEventListener('pointermove', (ev)=>{
  // 当没有拖拽物体时，按住 Shift 启用视角操作
  if(!dragged){
    controls.enableRotate = !!ev.shiftKey;
    controls.enablePan = !!ev.shiftKey;
    return;
  }
  // 如果正在拖拽，计算沿视线保持原始距离的目标点
  const pt = getMouseWorldPointAtDistance(ev.clientX, ev.clientY, dragged.distance);
  dragged.target.copy(pt);
});

    window.addEventListener('pointerup', (ev)=>{
  // 释放时默认关闭视角旋转/平移
  controls.enableRotate = false;
  controls.enablePan = false;
  if(dragged){
    try{
      // 恢复之前的阻尼
      dragged.body.linearDamping = dragged._prevLinearDamping !== undefined ? dragged._prevLinearDamping : 0.05;
      dragged.body.angularDamping = dragged._prevAngularDamping !== undefined ? dragged._prevAngularDamping : 0.3;
      // 减小速度，避免释放时被弹飞
      dragged.body.velocity.scale(0.2, dragged.body.velocity);
      dragged.body.angularVelocity.scale(0.2, dragged.body.angularVelocity);
    }catch(e){}
    dragged = null;
  }
});

    // 在物理步中应用弹簧力（在 animate 中 world.step 之前调用）

    // 初始样例
    addCube({size:1, mass:2, position: new THREE.Vector3(0.5, 2, 0), color: '#ff6b6b'});
    addCube({size:1.2, mass:1.5, position: new THREE.Vector3(-1.3, 3, 0.6), color: '#4d96ff'});

    // 性能提示：当物体数量很多时可以降低物理步长或禁用阴影
  </script>
</body>
</html>
